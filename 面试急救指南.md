# 前端面试急救手册

## JavaScript核心
### 闭包与作用域
```javascript

// 闭包示例
function createCounter() {
  let count = 0;
  return {
    increment() { count++; },
    getValue() { return count; }
  };
}

```



### 防抖
```javascript

// 防抖
function debounce(fn, delay) {
    let timer = null;
    if(timer) clearTimeout(timer);
    return function(...args) {
        timer =  setTimeout(() => fn.apply(...args), delay);
    }
}
// 带立即执行的防抖
function debounceImmediate (fn, delay, immediate = false) {
     let timer = null;
     return function(...args) {
        if(timer) clearTimeout(timer);
        if (immediate && !timer) {
            fn.apply(this, args);
        }
        timer = setTimeout(() => {
            if(!immediate){
                fn.apply(this, args);
            }
            timer = null;
        }, delay)
     }
}

```


### 节流
```javascript

function throttle(fn, delay) {
    let lastTime = 0;
    return function(...args){
        const now = Date.now();
        if(now - lastTime > delay){
            fn.apply(...args);
            lastTime = now;
        }
    }
}

```


## 算法与数据结构
### 两数之和
```javascript

function twoSum(nums, target) {
    const newMap = new Map();
    for (let i = 0; i < nums.length; i++) {
        const remainValue = target - nums[i];
        if (newMap.has(remainValue)) {
            return [newMap.get(remainValue), i];
        }
        newMap.set(nums[i], i);
    }
    return null;
}

// 1. 表单输入实时校验
// 场景：检查用户输入的「目标值」是否能由页面中其他两个输入框的值相加得到
const inputValues = [20, 30, 40];
const target = 50;
function checkCouponCombination(values, target) {
    const map = new Map();
    for(let i = 0; i < inputValues.length; i++){
        const component = target - values[i];
        if (map.has(component)) {
            return [values[map.get(component)], i];
        }
        map.set(values[i], i);
    }
    return null;
}

// 2.动态高光关联元素
// 场景：在数据可视化中高度显示和为特定值的两个元素
// 柱状图中高亮总和为100的两根柱子
const bars = [{value: 30}, {value: 70}, {value: 50}];
const targetSum = 100;

const highlightIndices = twoSum(bars.map(b => b.value), targetSum);
if (highlightIndices) {
    bars[highlightIndices[0]].highlightIndices = true;
    bars[highlightIndices[1]].highlightIndices = true;
}

// 3.权限组合校验
// 场景：检查用户权限列表中是否存在两种权限的组合权限
const userPermission = [1,3,5];
const adminPermission = 8;

twoSum(userPermission, adminPermission);

```



### 反转链表
```javascript

function reverseList(head) {
    let prev = null;
    let curr = head;
    while(curr){
        const next = curr.next;
        curr.next = prev;
        prev = next;
        next = curr;
    }
    return prev;
}

// 1. DOM 操作与动画
// 场景：实现“时光倒流”式动画，如撤销操作
// 用户操作记录的链表（每一步对应一个DOM状态）
let actionList = {
    value: "A",
    next: {
        value: "B",
        next: {
            value: "C",
            next: null
        }
    }
};
// 反转后倒序执行动画
const reversedActions = reverseList(actionList);
animate(reversedActions); // 从C → B → A回退

// 2. SPA（单页应用）中实现「双向路由跳转」
// 场景：路由/导航历史管理
// 路由历史链表（如 A → B → C）
let history = {
    path: "/home",
    next: {
        path: "/shop", next: null
    }
};
// 反转后可用于反向导航（如生成面包屑导航）
const reversedHistory = reverseList(history);
renderBreadcrumb(reversedHistory); // ["/shop", "/home"]

// 3. 数据可视化
// 场景：树状图/组织结构图的逆向渲染
// 原始数据（CEO → 总监 → 员工）
const orgChart = {
    name: "Alice",
    next: {
        name: "Bob",
        next: null
    }
};
// 反转后实现「自底向上」渲染
renderOrgChart(reverseList(orgChart));


```


### Vue响应式核心（Object.defineProperty）
```javascript

// 手写Vue2核心响应式（Object.defineProperty）
function defineReactive (obj, key, val) {
    const dep = new Dep();  // 生成依赖收集器
    Object.defineProperty(obj, key, {
        set(val) {
            dep.depend();   // 收集当前依赖
            return val;
        },
        get(newValue) {
            if (newValue === val) return;
            val = newValue;
            dep.notify();   // 通知依赖更新
        }
    })
}

// Vue3改用Proxy的优势：
// 1. 可监听数组下竖标的变化   2. 无需递归初始化   3. 支持动态新增属性



```


### Vue响应式核心（Object.defineProperty）
```javascript

// 实现观察者模式
class Dep {
    constructor() {
        this.subscribers = [];
    }
    depend() {
        if(target && !this.subscribers.includes(target)) {
            this.subscribers.push(target);
        }
    }
    notify() {
        this.subscribers.forEach(sub => sub());
    }
}
let target = null;
function watchEffect(effect) {
    target = effect;
    effect();
    target = null;
}
const dep = new Dep();
watchEffect(() => {
    console.log("数据变化了");
    dep.depend();  //模拟getter
});
dep.notify();  //模拟setter


```