# 前端面试急救手册

## JavaScript核心
### 闭包与作用域
```javascript

// 闭包示例
function createCounter() {
  let count = 0;
  return {
    increment() { count++; },
    getValue() { return count; }
  };
}

```



### 防抖
```javascript

// 防抖
function debounce(fn, delay) {
    let timer = null;
    if(timer) clearTimeout(timer);
    return function(...args) {
        timer =  setTimeout(() => fn.apply(...args), delay);
    }
}
// 带立即执行的防抖
function debounceImmediate (fn, delay, immediate = false) {
     let timer = null;
     return function(...args) {
        if(timer) clearTimeout(timer);
        if (immediate && !timer) {
            fn.apply(this, args);
        }
        timer = setTimeout(() => {
            if(!immediate){
                fn.apply(this, args);
            }
            timer = null;
        }, delay)
     }
}

```


### 节流
```javascript

function throttle(fn, delay) {
    let lastTime = 0;
    return function(...args){
        const now = Date.now();
        if(now - lastTime > delay){
            fn.apply(...args);
            lastTime = now;
        }
    }
}

```


## 算法与数据结构
### 两数之和
```javascript

function twoSum(nums, target) {
    const newMap = new Map();
    for (let i = 0; i < nums.length; i++) {
        const remainValue = target - nums[i];
        if (newMap.has(remainValue)) {
            return [newMap.get(remainValue), i];
        }
        newMap.set(nums[i], i);
    }
    return null;
}

// 1. 表单输入实时校验
// 场景：检查用户输入的「目标值」是否能由页面中其他两个输入框的值相加得到
const inputValues = [20, 30, 40];
const target = 50;
function checkCouponCombination(values, target) {
    const map = new Map();
    for(let i = 0; i < inputValues.length; i++){
        const component = target - values[i];
        if (map.has(component)) {
            return [values[map.get(component)], i];
        }
        map.set(values[i], i);
    }
    return null;
}

// 2.动态高光关联元素
// 场景：在数据可视化中高度显示和为特定值的两个元素
// 柱状图中高亮总和为100的两根柱子
const bars = [{value: 30}, {value: 70}, {value: 50}];
const targetSum = 100;

const highlightIndices = twoSum(bars.map(b => b.value), targetSum);
if (highlightIndices) {
    bars[highlightIndices[0]].highlightIndices = true;
    bars[highlightIndices[1]].highlightIndices = true;
}

// 3.权限组合校验
// 场景：检查用户权限列表中是否存在两种权限的组合权限
const userPermission = [1,3,5];
const adminPermission = 8;

twoSum(userPermission, adminPermission);

```



### 反转链表
```javascript

function reverseList(head) {
    let prev = null;
    let curr = head;
    while(curr){
        const next = curr.next;
        curr.next = prev;
        prev = next;
        next = curr;
    }
    return prev;
}

// 1. DOM 操作与动画
// 场景：实现“时光倒流”式动画，如撤销操作
// 用户操作记录的链表（每一步对应一个DOM状态）
let actionList = {
    value: "A",
    next: {
        value: "B",
        next: {
            value: "C",
            next: null
        }
    }
};
// 反转后倒序执行动画
const reversedActions = reverseList(actionList);
animate(reversedActions); // 从C → B → A回退

// 2. SPA（单页应用）中实现「双向路由跳转」
// 场景：路由/导航历史管理
// 路由历史链表（如 A → B → C）
let history = {
    path: "/home",
    next: {
        path: "/shop", next: null
    }
};
// 反转后可用于反向导航（如生成面包屑导航）
const reversedHistory = reverseList(history);
renderBreadcrumb(reversedHistory); // ["/shop", "/home"]

// 3. 数据可视化
// 场景：树状图/组织结构图的逆向渲染
// 原始数据（CEO → 总监 → 员工）
const orgChart = {
    name: "Alice",
    next: {
        name: "Bob",
        next: null
    }
};
// 反转后实现「自底向上」渲染
renderOrgChart(reverseList(orgChart));


```


### Vue响应式核心（Object.defineProperty）
```javascript

// 手写Vue2核心响应式（Object.defineProperty）
function defineReactive (obj, key, val) {
    const dep = new Dep();  // 生成依赖收集器
    Object.defineProperty(obj, key, {
        set(val) {
            dep.depend();   // 收集当前依赖
            return val;
        },
        get(newValue) {
            if (newValue === val) return;
            val = newValue;
            dep.notify();   // 通知依赖更新
        }
    })
}

// Vue3改用Proxy的优势：
// 1. 可监听数组下竖标的变化   2. 无需递归初始化   3. 支持动态新增属性



```


### Vue响应式核心（Object.defineProperty）
```javascript

// 实现观察者模式
class Dep {
    constructor() {
        this.subscribers = [];
    }
    depend() {
        if(target && !this.subscribers.includes(target)) {
            this.subscribers.push(target);
        }
    }
    notify() {
        this.subscribers.forEach(sub => sub());
    }
}
let target = null;
function watchEffect(effect) {
    target = effect;
    effect();
    target = null;
}
const dep = new Dep();
watchEffect(() => {
    console.log("数据变化了");
    dep.depend();  //模拟getter
});
dep.notify();  //模拟setter


```

## 自测问题
```javascript


// 1. “Vue3为什么用Proxy替代defineProperty？”
// 答：
// 可检测数组/对象增删
// 无需递归初始化
// 性能更好（懒代理）

// 补充：Proxy的局限性
// a.浏览器兼容性
// 不支持IE11（Vue3明确不兼容IE）
// b.调试难度
// Proxy的调用栈比defineProperty更深，调试时更复杂


// 2. “key为什么不能用index？”
// 答：
// 列表顺序变化时导致错误复用（如复选框状态错乱）
// 破坏组件生命周期（可能触发不必要的mounted）

// 3. 浏览器关键渲染路径（Critical Rendering Path）
//   A[HTML] --> B[DOM]
//   A --> C[CSSOM]
//   B & C --> D[Render Tree]
//   D --> E[Layout]
//   E --> F[Paint]
//   F --> G[Composite]

// 3.1 渲染名词解释
// CSSOM 浏览器生成树状结构，可以操作动态主题切换
// Render Tree 树状结构，只包含需要显示的节点
// Layout 布局，计算每个节点的位置
// Paint 绘制，将每个节点绘制到屏幕上
// Composite 合成，将页面分层，按层绘制

// 3.2 关键概念
// 阻塞渲染的资源：Head中的Css、未加async/defer的JS
// 优化原则
<link ref="stylesheets" href="example.css" media="all" /> // 延迟加载
<script defer src="app.js" /> // 延迟执行

// 4. 性能优化杀手
// 触发重排（修改几何属性）
element.style.width = "100px";
// 触发重绘（修改颜色等非几何属性）
element.style.color = "red";
// 4.1 检测工具
// Chrome DevTools --> Performance工具 --> 录制分析渲染耗时

// 5. webpack 分包策略
// vue.config.js 优化配置,通过将lodash/axios等稳定库单独分包，利用浏览器缓存，可以提升二次加载速度
configureWebpack(config, isServer) {
    optimization: {
        splitChunks: {
            chunks: "all",
            cacheGroups: {
                vendor: {
                    name: "vendor",
                    test: /[\\/]node_modules[\\/](lodash|axios)[\\/]/,
                    priority: -10
                },
                common: {
                    name: "common",
                    minChunks: 2,
                    priority: -20
                }
            }
        }
    }
}

// 6. 如何分析页面性能瓶颈
// a. Lighthouse生成报告（重点关注LCP/CLS/TTI）
// b. Chrome Performance面板录制查找长任务
// c. Webpack Bundle Analyzer分析包体积

// 7. 哪些操作会导致强制同步布局
// 错误示例（强制同步布局）
const width = element.offsetWidth; // 触发重排
element.style.width = width + 'px';


```